\tableofcontents
\setcounter{page}{2}
\chapter{Функции обработчика прерывания от системного таймера}

\section[Функции обработчика прерывания от системного таймера в ОС семейства UNIX]
{Функции обработчика прерывания от системного таймера в ОС семейства \\ UNIX}

По тику:
\begin{itemize}
	\item увеличение значения поля \textit{p\_cpu} дескриптора текущего процесса до максимального значения, равного 127;
	\item инкремент счётчика реального времени;
	\item декремент кванта текущего потока;
	\item инкремент счётчика времени в будильниках 3 типов.
\end{itemize}

По главному тику:
\begin{itemize}
	\item пробуждение системных процессов, таких как \textit{pagedaemon} и \textit{swapper};
	\item обработка отложенных вызовов;
	\item декремент счётчика времени до отправки одного из сигналов среди SIGALRM, SIGPROF, SIGVTALRM.
\end{itemize}

По истечении кванта обработчик прерывания по кванту посылает текущему процессу сигнал SIGXCPU.

Чаще всего квант времени в традиционных системах UNIX равен 100 миллисекундам.

\section[Функции обработчика прерывания от системного таймера в ОС семейства Windows]
{Функции обработчика прерывания от системного таймера в ОС семейства \\Windows}

По тику:
\begin{itemize}
	\item декремент кванта текущего потока;
	\item декремент счётчика отложенных задач;
	\item инкремент счётчика реального времени;
	\item инициализация отложенного вызова обработчика ловушки профилирования ядра с помощью 
	постановки объекта в очередь DPC (Deferred Procedure Call), если активен механизм профилирования ядра.
\end{itemize}

По главному тику:
\begin{itemize}
	\item освобождение объекта ядра <<событие>>;
	\item добавление в очередь DPC объекта диспетчера настройки баланса.
\end{itemize}

По истечении кванта обработчик прерывания инициализирует диспетчеризацию потоков.

Чаще всего на клиентской версии ОС Windows поток выполняется в течение двух
интервалов таймера, на серверных --- 12 интервалов. Однако значение
кванта может варироваться от системы к системе. 

\chapter{Динамические приоритеты}

В ОС семейств UNIX или Windows динамическими могут быть только пользовательские приоритеты, то есть приоритеты пользовательских процессов.
Приоритеты процессов ядра являются фиксированными величинами.

Во всех системах учитываются время простоя процесса в очереди готовых процессов и причина блокировки процесса.

Планировщик (scheduler) --- часть ядра, распределяющая процессорное время между процессами или потоками.

\section[Динамические приоритеты в ОС семейства UNIX]{Динамические приоритеты в ОС \\семейства UNIX}

В традиционных системах UNIX планировщик использует алгоритм Round Robin.
Процессы, имеющие одинаковые приоритеты, будут выполняться циклически друг за другом, и каждому из них
будет отведён для этого квант времени, обычно равный 100 миллисекундам.
Если какой-то процесс с более высоким приоритетом становится выполняемым, то он вытеснит текущий процесс (если текущий процесс не находится в режиме ядра)
даже в том случае, если текущий процесс не исчерпал отведённый ему квант времени.

Также в традиционных системах UNIX приоритет процесса определяется двумя факторами:
фактором <<любезности>> и фактором утилизации. Фактор утилизации ---
время последнего обслуживания процесса процессором. Ядро периодически
повышает приоритет процесса, пока тот не выполняется. а после того как процесс
получит процессорное время, его приоритет будет понижен.

Приоритеты ядра являются фиксированными величинами и зависят только
от причины засыпания процесса, поэтому приоритеты ядра также известны как
приоритеты сна. 

В таблице \ref{tbl:sleep2} приведены приоритеты сна в ОС 4.3BSD UNIX.

\begin{table}[h!]
	\centering
	\caption{Приоритеты сна в ОС 4.3BSD UNIX}
	\begin{tabular}{|c|c|c|}
		\hline
		Приоритет & Значение & Описание \\
		\hline
		PSWP & 0 & Свопинг \\
		\hline
		PSWP + 1 & 1 & Страничный демон \\
		\hline 
		PSWP + 1/2/4 & 1/2/4 & Другие действия по обработке памяти \\
		\hline
		PINOD & 10 & Ожидание освобождение inode \\
		\hline
		PRIBIO & 20 & Ожидание дискового ввода-вывода \\ 
		\hline
		PRIBIO + 1 & 21 & Ожидание освобождения буфера \\
		\hline
		PZERO & 25 & Базовый приоритет\\
		\hline
		TTIPRI & 28 & Ожидание ввода с терминала\\
		\hline
		TTOPRI & 29 & Ожидание вывода с терминала\\
		\hline
		PWAIT & 30 & Ожидание завершения процесса-потомка\\
		\hline
		PLOCK & 35 & \makecell{Консультативное ожидание\\блокированного ресурса}\\
		\hline
		PSLEP & 40 & Ожидание сигнала\\
		\hline
	\end{tabular}
	\label{tbl:sleep2}
\end{table}

В отличие от ОС семейства Windows, в ОС семейства UNIX планировщик
является отдельным компонентом ОС. Изначально система UNIX 
создавалась как система разделения времени, что означает 
одновременное выполнение нескольких процессов.

Далее будет обсуждаться традиционный алгоритм планирования,
применимый как в SVR3, так и в 4.3BSD.

Планировщик выбирает процессы, обаладающие наиболее высоким приоритетом.
Для диспетчеризации процессов с равным приоритетом применяется 
вытесняющее квантование времени. Системой учитывается количество 
используемого процессами процессорного времени.

Традиционной ядро UNIX является невытесняющим.

Приоритет процесса задаётся любым целым числом, лежащим в 
диапозоне от 0 до 127. Чем меньше такое число, тем выше приоритет.
Приоритеты от 0 до 40 зарезервированы ядром, остальные приоритеты 
используются прикладными процессамми.

Структура 	\textit{proc} содержит следующим поля, относящиеся к приоритетам:
\begin{itemize}
	\item 	\textit{p\_pri} --- текущий приоритет планирования;
	\item 	\textit{p\_usrpri} --- приоритет режима задачи;
	\item 	\textit{p\_cpu} --- результат последнего измерения использования процессора;
	\item 	\textit{p\_nice} --- фактор <<любезности>>, устанавливаемый пользователем.
\end{itemize}

Поля 	\textit{p\_pri} и 	\textit{p\_usrpri} применяются для различных целей.
Поле 	\textit{p\_pri} используется планировщиком для принятия решения о том,
какой процесс надо направить на выполнение. Если процесс находится в режиме задачи,
то в его дескрипторе значение 	\textit{p\_pri} идентично 	\textit{p\_usrpri}.
Когда процесс проснётся после
блокировки в системном вызове, его приоритет будет временно повышен для того,
чтобы дать ему предпочтение для выполнения в режиме ядра. Значит,
планировщик использует поле 	\textit{p\_usrpri} для хранения приоритета, который
будет назначен процессу при возврате в режим задачи, а 	\textit{p\_pri} --- для 
хранения временного приоритета для выполнения в режиме ядра.

Также ядро системы связывает приоритет сна с событием или ожидаемым
ресурсом, из-за которого процесс может заблокироваться. Приоритет сна
является величиной, определяемой для ядра, и поэтому располагается в 
диапазоне 0--49. 

В таблице \ref{tbl:sleep} приведены системные приоритеты сна.

\begin{table}[h!]
	\centering
	\caption{Системные приоритеты сна}
	\begin{tabular}{|c|c|c|}
		\hline
		Событие & \makecell{Приоритет \\4.3BSD UNIX} & \makecell{Приоритет \\SCO UNIX} \\
		\hline
		\makecell{Ожидание загрузки в \\память сегмента\\/страницы} & 0 & 95 \\
		\hline
		Ожидание индексного дескриптора & 10 & 88 \\
		\hline
		Ожидание ввода-вывода & 20 & 81 \\
		\hline
		Ожидание буфера & 30 & 80 \\
		\hline
		Ожидание терминального ввода & & 75 \\
		\hline
		Ожидание терминального вывода & & 74 \\
		\hline
		Ожидание завершения выполнения & & 73 \\
		\hline
		\makecell{Ожидание события --- \\низкоприоритетное состояние сна} & 40 & 66 \\
		\hline
	\end{tabular}
	\label{tbl:sleep}
\end{table}

Когда процесс пробуждается, ядро устанавливает значение текущего приоритета процесса
равным приоритету сна. Поскольку приоритет такого процесса находится в системном 
диапазоне и выше, чем любой приоритет режима задачи, вероятность
предоставления процессу вычислительных ресурсов весьма велика.

После завершения системного вызова перед возвращением в режим задачи
ядро восстанавливает приоритет режима задачи, сохранённый
перед выполнением системного вызова.

Каждую секунду ядро системы вызывает процедуру \textit{schedcpu()}, которая
уменьшает значение \textit{p\_cpu} каждого процесса исходя из фактора <<полураспада>> 
(decay factor). В системе SVR3 фактор <<полураспада>> равен $\frac{1}{2}$, однако в 
4.3BSD для расчёта фактора используется следующая формула:
\begin{equation}
	decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1},
\end{equation}
где $load\_average$ --- это среднее количество процессов, находящихся в состоянии 
готовности к выполнению, за последнюю секунду. Процедура \\ \textit{schedcpu()} 
пересчитывает приоритеты для всех процессов находящихся в режиме задачи по формуле:
\begin{equation}
	p\_usrpri = PUSER + \frac{p\_cpu}{4} + 2 \cdot p\_nice,
\end{equation}
где $PUSER$ --- базовый приоритет в режиме задачи, равный 50.

В результате, если процесс до вытеснения другим процессом использовал большое 
количество процессорного времени, его \textit{p\_cpu} будет увеличен, что приведёт к 
росту значения \textit{p\_usrpri}, а это повлечёт за собой к понижению приоритета 
процесса. Такая схема предотвращает бесконечное откладывание.

\section[Динамические приоритеты в ОС семейства Windows]{Динамические приоритеты в ОС \\семейства Windows}

В Windows реализуется приоритетная, вытесняющая система планирования, 
при которой выполняется хотя бы 1 поток с самым высоким приоритетом.

После выбора потока для запуска, он запускается на время, называемое квантом.
Но поток может и не израсходовать свой квант времени, так как в Windows реализуется вытесняющий планировщик:
 если становится готов к запуску другой поток с более высоким приоритетом, текущий выполяемый поток может быть вытеснен ещё до окончания его кванта времени.
Возможна ситуация, при которой поток может быть выбран на запуск следующим и вытеснен ещё даже до начала своего кванта времени.

ОС назначает приоритет процессу и приоритет потоку относительно приоритета процесса.
 
В ОС семейства Windows нет отдельного модуля планировщика. 
Функции планировщика выполняют различные участки кода ядра системы, 
которые называются диспетчером ядра.

Также стоит отметить <<родственность процессора>> --- явление, 
при котором готовые к запуску потоки с самым
высоким приоритетом могут быть ограничены
процессорами, на которых
им разрешено или предпочтительнее всего работать.

По совокупности следующих обстоятельств Windows определяет,
какой поток должен быть запущен следующим на логическом процессоре, или 
на каком логическом процессоре он не должен быть запущен:

\begin{enumerate}
	\item Поток становится готовым к выполнению.
	\item Поток выходит из состояния выполнения из-за окончания его кванта времени.
	\item Изменяется приоритет потока.
	\item Изменяется родственность процессора потока и он больше уже не может 
	быть запущен на том процессоре, на котором выполнялся.
\end{enumerate}

Решения по планированию принимаются только на основе потоков.

Windows использует 32 уровня приоритетов, от 0 до 31.
\begin{itemize}
	\item 16 уровней реального времени (от 16 до 31);
	\item 16 уровней (от 0 до 15), 0-ой уровень зарезервирован для потока обнуления страниц.
\end{itemize}

Уровни приоритета потоков назначаются исходя из двух разных позиций:
одной от Windows API и другой от ядра Windows.
Windows API систематизирует процессы по классу приоритета, который им присваивается при создании
(номера представляют внутренний индекс ~\\~PROCESS\_PRIORITY\_CLASS, распознаваемый ядром).

Процесс наследует базовый приоритет от процесса, которые его создал. 
Потока наследует базовый приоритет от своего процесса. Это поведение
может быть изменено.

Классы приоритета процесса:
\begin{itemize}
	\item реального времени --- Real-time (4);
	\item высокий --- High (3);
	\item выше обычного --- Above normal (7);
	\item обычный --- Normal (2);
	\item ниже обычного --- Below Normal (5);
	\item простой --- Idle (1).
\end{itemize}

Далее назначается относительный приоритет отдельным потокам внутри 
этих процессов. Номера представляют изменение приоритета,
применяющееся к базовому приоритету процесса.

Относительные приоритеты потоков:
\begin{itemize}
	\item критичный по времени --- Time-critical (15);
	\item наивысший --- Highest (2);
	\item выше обычного --- Above normal (1);
	\item обычный --- Normal (0);
	\item ниже обычного --- Below-normal (-1);
	\item самый низший --- Lowest (-2);
	\item простой --- Idle (-15).
\end{itemize}

В Windows API каждый поток имеет базовый приоритет, который является
функцией класса приоритета процесса и относительного приоритета потока. 
В ядре класс приоритета процесса преобразуется в базовый приоритет. Затем
применяется относительный приоритет потока в качестве разницы для этого 
базового приоритета.

Далее будет представлено отображение Windows-приоритета на внутренние
номерные приоритеты Windows.

\imgHeight{55mm}{otobr_win.png}{Отображение Windows-приоритета на внутренние
	номерные приоритеты Windows}

Потоки с относительным приоритетом Time-Critical и Idle сохраняют
номерные приоритеты вне зависимости от класса приоритета процесса (Только
если этим классом не является Realtime). Дело в том, что Windows API
требует насыщения приоритета от ядра. Ядро распознает запрос на насыщение 
и это приведёт к тому, что при положительном насыщении поток будет иметь
наивысший приоритет внутри его класса приоритета, при отрицательном --- 
наименьший приоритет.

Планировщик Windows периодически настраивает текущий приоритет 
потоков, используя внутренний механизм повышения приоритета. 
Повышение применяется для предотвращения сценариев смены 
приоритетов и зависаний.

Ряд сценариев повышения приоритета:
\begin{itemize}
	\item повышение вследствие событий планировщика или диспетчера (сокращение задержек);
	\item повышение вследствие завершения ввода-вывода (сокращение задержек);
	\item повышение вследствие ввода из пользовательского интерфейса (сокращение задержек и времени отклика);
	\item повышение вследствие слишком продолжительного 
	ожидания ресурса исполняющей системы (предотвращение зависания);
	\item повышение в случае, когда готовый к запуску поток не был запущен в 
	течение определённого времени (предотвращение зависания и смены приоритетов);
	\item повышение приоритета владельца блокировки;
	\item повышение, связанное с завершением ожидания;
	\item повышение приоритета потоков первого плана после ожидания;
	\item повышение приоритета, связанные с перезагруженностью центрального процессора.
\end{itemize}

Windows даёт временное повышение приоритета при завершении определённых
операций ввода-вывода потокам, ожидающих ввод-вывод.

\imgHeight{40mm}{io_values.png}{Рекомендуемые от Microsoft значения повышения приоритета}

Ядро реализует код подачи сигнала в API-функции \textit{IoCompleteRequest},
используя либо APC, либо событие. При передаче драйвером параметра 
\textit{IO\_DISK\_INCREMENT}
в функцию \textit{IoCompleteRequest}
для асинхронного чтения диска ядро вызывает \textit{KeInsertQueueApc} 
с параметром повышения \textit{IO\_DISK\_INCREMENT}. Когда ожидание потока 
разрушается из-за APC, он получает повышение, равное 1.

Также стоит отметить отдельно повышение приоритета проигрывания
мультимедиа. MMCSS (MultiMedia Class Scheduler Service) --- 
служба планировщика класса мультимедиа. Упомянутое повышение 
\textbf{не является настоящим повышением}, служба устанавливает
новые базовые приоритеты для потоков. 

Одно из наиболее важных свойств для планирования потоков, 
зарегистрированных с MMCSS, называется
категорией планирования. Далее представлены категории планирования.

\imgHeight{65mm}{mmcss.png}{Категории планирования}

Механизм, положенный в основу MMCSS, повышает приоритет потоков
внутри зарегистрированного процесса до уровня, соответствующего 
их категории планирования и относительного приоритета внутри этой 
категории на время. По истечении времени он снижает категорию 
этих потоков до Exhausted.

Windows устававливает свою собственную схему приоритетности 
прерываний --- уровни запросов прерываний (IRQL, Interrupt Request Level).
Уровни представлены в виде номеров от 0 до 31 на системах x86. Более высоким номерам 
соответствуют прерывания с более высоким приоритетом.

\imgHeight{80mm}{irql.png}{Уровни запросов прерываний для архитектуры x86}

Прерывания обслуживаются в порядке их приоритета, и прерывания с более 
высоким уровнем приоритета получают преимущество в обслуживании. Процессор
сохраняет состояние прерванного потока и запускает связанный 
с прерыванием диспетчер системных прерываний при возникновении прерывания
с более высоким уровнем приоритета. 

В Windows включён общий механизм ослабления загруженности центрального 
процессора, который называется диспетчером настройки баланса.

Раз в секунду системный поток, который существует для выполнения 
функций управления памятью, сканирует очередь готовых процессов в 
поиске тех, которые находятся в состоянии ожидания около 4 секунд. Если
такой поток будет найден, диспетчер настройки баланса повышает его 
приоритет до 15 единиц и устанавливает квантовую цель эквивалетной
тактовой частоте процессора при подсчёте 3 квантовых единиц. По истечении
кванта приоритет потока будет снижен до обычного базового. Однако
диспетчер на самом деле не сканирует все потоки, а только 16 готовых 
потоков и за 1 проход может повысить приоритет только 10 потоков.







