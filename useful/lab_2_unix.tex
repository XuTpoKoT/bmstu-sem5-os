\chapter{Лабораторная по Unix №2}

Типы файлов:
\begin{itemize}
	\item исполняемый
\end{itemize}
	
\section{fork}
Системный вызов fork() создает новый процесс, который находится в отношении потомок-предок. Это отношение поддерживается в структуре proc соотв. указателями. 
Процесс-потомок является копией процесса-предка: процесс-потомок наследует код (программу) предка, дескрипторы открытых файлов (в том числе программных каналов), сигнальную маску, маску режима создадия файлов, окружение.

//доп.\\
Другими словами, программа, которую выполняет процесс-потомок является программой родительского процесса. Процесс потомок и процесс-родитель разделяют одно и то же адрусное пр-во. ?области данных и стека. Процесс-потомок начинает работу в режиме задачи после возвращения из системного вызова fork(). Тот факт, что образы памяти, переменные, регистры и все остальное и у родительского процесса, и у дочернего идентичны, могло бы привести  к невозможности различить эти процессы, однако, системный вызов fork() возвращает дочернему процессу число 0, а родительскому —  PID (Process IDentifier — идентификатор процесса) дочернего процесса. Оба процесса обычно проверяют возвращаемое значение и действуют соответственно.

//доп.\\
Если вызов fork() завершается аварийно, он возвращает -1. Обычно это происходит из-за ограничения числа дочерних процессов, которые может иметь родительский процесс (CHILD\_MAX), в этом случае переменной errno будет присвоено значение EAGAIN. Если для элемента таблицы процессов недостаточно места или не хватает памяти, переменная errno получит значение ENOMEM.

В старых Unix-системах код предка копировался в адресное пространство потомка. Для потомка создавалось собственное адресное пространство(таблицы страниц). В результате создавалось несколько копий одной программы, что не эффективно. В современных системах исользуется оптимизированный fork(): для процесса потомка создаются собственные карты трансляции адресов (таблицы страниц), но дескрипторы этих страниц ссылаются на адресное пространство процесса-предка (на страницы предка). При этом для страниц адресного пространства предка права доступа меняются с read-write на only-read и (в дескрипторе каждой страницы) устанавливается флаг copy-on-write. Если предок или потомок попытаются изменить страницу, возникнет исключение по правам доступа. Обработчик исключения обнаружит установленный флаг copy-on-write и создаст копию страницы в адресном пространстве того процесса, который пытался ее изменить. Таким образом код процесса-предка не копируется полностью, а создаются только копии страниц, которые редактируются.
Такая ситуация в системе сохраняется до тех пор, пока потомок не вызовет exit или exec.

\section{exec}
В результате системного вызова exec() адресное пространство процесса будет заменено на адресное пространство программы, которая передана exec в качестве параметра. Говорят, что системный вызов exec() создает так называемый низкоуровневый процесс: на самом деле процесс не создаётся (у него нет идентификатора и дескриптора), но создаются таблицы страниц для адресного пространства программы, указанной в exec().

\begin{itemize}
	\item Разбирает путь к файлу (для системы это строка символов) и осуществляет доступ к нему.
	\item Проверяются права на выполнение файла.
	\item Если файл существ., проверяется что он исполняемый (по заголовку файла).
	\item Высвобождает старое адресное пр-во.
	\item Создаёт таблицы страниц для (виртуального) адресного пространства программы, переданной exec в качестве параметра.
	\item Заменяет в дескрипторе процесса старый адрес таблицы страниц на новый
	\item Сбрасывает все обработчики сигналов в дей-я, определённые по умолчанию.
	\item Инициализируется аппаратный контекст. При этом большинство регистров сбрасывается в 0.
\end{itemize}

Чтобы программа выполнилась, адрес точки входа надо загрузить в instruction\_pointer.
Для Intel: в регистр CR3 нужно загрузить адрес программы, переданной exec в качестве параметра (? без этого невозможна адресация).
? В других системах - program\_counter.

//доп.\\
В результате флаг copy-on-write сбрасывается. Сам процесс будет возвращен в режим задачи с установкой указателя команд на первую выполняемую инструкцию этой программы.

\section{wait}
Cистемный вызов wait() блокирует родительский процесс до момента завершения дочернего.
При этом процесс-предок получает статус завершения процесса-потомка.

Вызов возвращает PID дочернего процесса. Обычно это дочерний процесс, который завершился. Сведения о состоянии позволяют родительскому процессу определить статус завершения дочернего процесса, т.е. значение, возвращенное из функции main потомка или переданное функции exit(). Если stat\_loc не равен пустому указателю, информация о состоянии будет записана в то место, на которое указывает этот параметр.

\begin{itemize}
	\item WIFEXITED
	\item WEXITSTATUS
	\item WIFSIGNALED
	\item WTERMSIG
	\item WIFSTOPPED
	\item WSTOPSIG
\end{itemize}

pid\_t waitpid(pid\_t pid, int *stat\_loc, int options);

Аргумент pid — конкретный дочерний процесс, окончания которого нужно ждать. Если он равен –1, waitpid()  возвращает  информацию о любом дочернем процессе. Как и вызов wait(), он записывает информацию о состоянии процесса в то место, которое указывает аргумент stat\_loc, если последний не равен пустому указателю. Аргумент options позволяет изменить поведение waitpid. Наиболее полезная опция WNOHANG мешает вызову waitpid() приостанавливать выполнение вызвавшего его процесса. Она применяется для определения, завершился ли какой-либо из дочерних процессов, и если нет, то можно продолжить выполнение. Остальные опции такие же, как в вызове wait().

И так для того, чтобы родительский процесс периодически проверял, завершился ли конкретный дочерний процесс, можно использовать следующий вызов:

waitpid(child\_pid, (int *)0, WNOHANG);

Он вернет ноль, если дочерний процесс не завершился и не остановлен, или child\_pid, если это произошло. Вызов waitpid вернет -1 в случае ошибки и установит переменную errno. Это может произойти, если нет дочерних процессов (errno равна ECHILD), если вызов прерван сигналом (EINTR) или аргумент options неверный (EINVAL).

\section{Процесс-зомби}
Когда дочерний процесс завершается, связь его с родителем сохраняется до тех пор, пока родительский процесс в свою очередь не завершится нормально, или не вызовет wait(). Следовательно, запись о дочернем процессе не исчезает из таблицы процессов немедленно. Становясь неактивным, дочерний процесс все еще остается в системе, поскольку его код завершения должен быть сохранен, на случай если родительский процесс в дальнейшем вызовет wait(). 

Процесс-зомби – это процесс, у которого отобраны все ресурсы, кроме последнего – строки в таблице процессов. Это сделано для того, чтобы процесс-предок, вызвавший системный вызов wait(), не был заблокирован навсегда.

Можно увидеть переход процесса в состояние зомби, если дочерний процесс завершиться первым, то он будет существовать как зомби, пока процесс-предок или вызовет системный вызов wait(), или  родительский процесс завершиться.

\section{Программные каналы}
Программные каналы -- базовое средство взаимодействия между процессами.
У каналов односторонняя (симпликсная) связь.
Любой прог. канал -- буфер в области данных ядра типа FIFO. 
Процессы в мультизадачных ОС являются защищёнными (имеют защищённые адресные пространства). Пр-с не может обратиться в адресное пр-во др. процесса, они могут взыимодействовать только через адресное пространство ядра.

Виды ПК:
\begin{itemize}
	\item именованный (mknode). У него есть имя, дескриптор, номер. 
	\item неименованный (pipe). Нет имени, есть дескриптор(inode). Неименованные программные каналы могут использоваться для обмена сообщениями между процессами-родственниками.
	Процесс-потомок наследует все дескрипторы открытых файлов процесса-предка, в том числе и неименованных программных каналов.
\end{itemize}

Программные каналы имеют встроенные средства взаимоисключения -- массив файловых дескрипторов: из канала нельзя читать, если в него пишут, и в канал нельзя писать, если из него читают.

Прог. каналы буферезуются на 3-х уровнях: 
\begin{itemize}
	\item В ядре системы. При переполнении системы ... переписывается на диск, при этом исп. станд. ф-и read-write. Если пр-с записывает в ПК > 4096 байт, то он блокируется до тех пор,  пока из канала всё не прочитают. -> мы не пишепм размер канала(он всегда 4096 байт - 1 страница, чтобы быстрее передавать данные). 
	\item 
	\item 
\end{itemize}
	
\section{Сигналы}

Сигнал -- способ информирования процесса ядром о происшествии какого-то события. Если возникает несколько однотипных событий, процессу будет подан только один сигнал. Сигнал означает, что произошло событие, но ядро не сообщает сколько таких событий произошло.

Обычно, получение процессом сигнала предписывает ему завершиться. Вместе с тем процесс может установить собственную реакцию на получаемый сигнал. Например, получив сигнал процесс может его проигнорировать, или вызвать на выполнение некоторую программу, а после ее завершения продолжить выполнение с точки получения сигнала.

Установить реакцию на поступление сигнала можно с помощью системного вызова signal(): 
func = signal(snum, function);

Где snum - номер сигнала, а function - адрес функции, которая должна быть выполнена при поступлении указанного сигнала. Возвращаемое значение -- адрес функции, которая будет реагировать на поступление сигнала. Вместо function можно указать ноль или единицу. Если был указан ноль, то при поступлении сигнала snum выполнение процесса будет прервано аналогично вызову exit. Если указать единицу, данный сигнал будет проигнорирован, но это возможно не для всех процессов.

Системный вызов signal() возвращает указатель на предыдущий обработчик данного сигнала. Его можно использовать для восстановления обработчика сигнала.

С помощью системного вызова kill() можно сгенерировать сигналы и передать их другим процессам. 
kill(pid, snum); 
где pid - идентификатор процесса, а snum - номер сигнала, который будет передан процессу. Обычно kill() используется для того, чтобы принудительно завершить (``убить'') процесс. 

Pid состоит из идентификатора группы процессов и идентификатора процесса в группе. Если вместо pid указать нуль, то сигнал snum будет направлен всем процессам, относящимся к данной группе (понятие группы процессов аналогично группе пользователей). В одну группу включаются процессы, имеющие общего предка, идентификатор группы процесса можно изменить с помощью системного вызова setpgrp. Если вместо pid указать -1, ядро передаст сигнал всем процессам, идентификатор пользователя которых равен идентификатору текущего выполнения процесса, который посылает сигнал.

\chapter{Процесы-демоны}

